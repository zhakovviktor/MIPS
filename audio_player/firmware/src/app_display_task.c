/*******************************************************************************
  Universal Audio Decoders Demo

  Company:
    Microchip Technology Inc.

  File Name:
    app_display_task.c

  Summary:
    Contains functional implementation of display task.

  Description:
    Contains functional implementation of display task that responds to events
    generated by the GUI and forwards the same to the sdcard audio task. 
    Similarly, the requests from the sdcard audio task are forwarded by the 
    display task to the GUI.
 *******************************************************************************/

// DOM-IGNORE-BEGIN
/*******************************************************************************
Copyright (c) 2016-2017 released Microchip Technology Inc.  All rights reserved.

Microchip licenses to you the right to use, modify, copy and distribute
Software only when embedded on a Microchip microcontroller or digital signal
controller that is integrated into your product or third party product
(pursuant to the sublicense terms in the accompanying license agreement).

You should refer to the license agreement accompanying this Software for
additional information regarding your rights and obligations.

SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
(INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
 *******************************************************************************/
// DOM-IGNORE-END

// *****************************************************************************
// *****************************************************************************
// Section: Included Files
// *****************************************************************************
// *****************************************************************************

#include "DIALOG.h"
#include "app_display_task.h"
#include "app_sdcard_audio_task.h"

DISPLAY_TASK_DATA displayTaskData;

static void initQueue(MSG_QUEUE* pQueue, uint8_t* pBuffer, uint16_t maxLen)
{    
    pQueue->inPtr = pQueue->outPtr = 0;
    pQueue->pBuffer = pBuffer;
    pQueue->maxLen = maxLen;        
}

__attribute__((unused)) static void flushQueue(MSG_QUEUE* pQueue)
{    
    pQueue->inPtr = pQueue->outPtr = 0;        
}

__attribute__((unused)) static bool isQueued(MSG_QUEUE* pQueue)
{    
    bool isQueued = false;    
    
    if (pQueue->inPtr != pQueue->outPtr)
    {
        isQueued = true;
    }        
    
    return isQueued;
}

static bool pullQueue(MSG_QUEUE* pQueue, uint8_t* pVal)
{
    bool isSuccess = false;
                
    if (pQueue->inPtr != pQueue->outPtr)
    {
        *pVal = pQueue->pBuffer[pQueue->outPtr];
        pQueue->outPtr++;
        if (pQueue->outPtr >= pQueue->maxLen)
        {
            pQueue->outPtr = 0;
        }
        isSuccess = true;
    }    
    
    return isSuccess;
}

static bool pushQueue(MSG_QUEUE* pQueue, uint8_t value)
{
    bool isSuccess = false;
    uint16_t temp = pQueue->inPtr + 1;
    
    if (temp >= pQueue->maxLen)
    {
        temp = 0;
    }
    if (temp != pQueue->outPtr)
    {
        pQueue->pBuffer[pQueue->inPtr] = value;
        pQueue->inPtr = temp;
        isSuccess = true;
    }        
    
    return isSuccess;
}

__attribute__((unused)) static bool isQueueFull(MSG_QUEUE* pQueue)
{
    bool isQueueFull = false;
    uint16_t temp = pQueue->inPtr + 1;
    
    if (temp >= pQueue->maxLen)
    {
        temp = 0;
    }
    if (temp == pQueue->outPtr)
    {
        isQueueFull = true;
    }       
    
    return isQueueFull;
}

static int8_t *_APP_DISPLAY_GetFileName(const int8_t *path)
{
    int8_t *filename = (int8_t*)strrchr((const char*)path, '/');
    if (filename == NULL)
        filename = (int8_t *)path;
    else
        filename++;
    return filename;
}

static bool APP_DISPLAY_IsGUIScreenInitialized(void)
{
    return isGuiScreenInitialized();
}

static void APP_DISPLAY_PlayerStateChangeEvent(PLAY_BUTTON_STATES playerState)
{
    APP_SDCARD_AUDIO_UpdatePlayerRunningStatus(playerState);
}
static void APP_DISPLAY_AddTrackListItem(const char* pString)
{
    addListBoxItem(pString);
}

static bool APP_DISPLAY_ReadModeSwitch(void)
{
    return getUSBModeSwitchState();
}

static uint32_t APP_DISPLAY_GetSelectedTrack(void)
{
    return getListBoxSelectedItem();
}

static void APP_DISPLAY_UpdatePlayerProgressBarReq(uint8_t timeInPer)
{
    updateProgressBar(timeInPer);
}

static uint32_t APP_DISPLAY_GetVolumeLevel(void)
{
    uint32_t volLevel = 0;
    uint32_t sliderMaxValue = 0;
    
    volLevel = getSliderValue();
    sliderMaxValue = getMaxSliderValue();
    volLevel *= APP_DISPLAY_VOLUME_MAX;
    volLevel /= sliderMaxValue;
    
    return volLevel;
}

static void APP_DISPLAY_SeekTrackPositionEvent(void)
{    
    int64_t position = APP_SDCARD_AUDIO_GetCurrentFileSizeBytes();
    position = (position * getTrackSeekValue())/(int64_t)100;
        
    APP_SDCARD_AUDIO_SeekTrackPosition(position);        
}

static void APP_DISPLAY_SetVolumeLevelReq(uint32_t volLevel)
{
    volLevel = (volLevel*100)/APP_DISPLAY_VOLUME_MAX;
    setSliderValue(volLevel);
}

static void APP_DISPLAY_SetSelectedTrackReq(uint32_t track)
{
    setListBoxSelectedItem(track);
}

static void APP_DISPLAY_TurnMuteOnEvent(void)
{
    APP_SDCARD_AUDIO_MuteOn();
}

static void APP_DISPLAY_ControlMuteButtonRequest(bool isOn)
{
    volMuteButtonControl(isOn);
}
static void APP_DISPLAY_PlayerStateChangeRequest(PLAY_BUTTON_STATES playerState)
{
    updatePlayButtonState(playerState);
}

static void APP_DISPLAY_TurnMuteOffEvent(void)
{
    APP_SDCARD_AUDIO_MuteOff();
}

static void APP_DISPLAY_UpdateElapsedTimeReq(uint32_t totalTrackTime, uint32_t totalTrackTimeInBytes, uint32_t totalElapsedTimeInBytes)
{
    uint32_t elapsedTime;
    uint32_t mins = 0;
    uint32_t secs = 0;
    uint8_t buffer[6] = {0};
    
    //Avoid a potential divide by zero
    if (totalTrackTimeInBytes)
    {
    
        elapsedTime = ((uint64_t)totalElapsedTimeInBytes * (uint64_t)totalTrackTime)/(uint64_t)totalTrackTimeInBytes;
        if (elapsedTime > 59)
        {
            mins = elapsedTime/60;
            secs = elapsedTime - (mins * 60);
        }
        else
        {        
            secs = elapsedTime;
        }
        sprintf((char*)buffer, "%02d:%02d", mins, secs);
        updateElapsedTrackTime(buffer);        
    }        
}

static void APP_DISPLAY_ModeChangeRequest(SWITCH_BUTTON_STATES switchState)
{
    setUSBModeSwitchState(switchState);
}

static void APP_DISPLAY_UpdateTrackDurationReq(void)
{
    uint32_t mins = 0;
    uint32_t secs = 0;
    uint8_t buffer[6] = {0};
    
    uint32_t total_time = APP_SDCARD_AUDIO_GetTrackPlayTime();
    if (total_time > 59)
    {
        mins = total_time/60;
        secs = total_time - (mins * 60);
    }
    else
    {        
        secs = total_time;
    }
    sprintf((char*)buffer, "%02d:%02d", mins, secs);
    updateTotalTrackTime(buffer);    
}

static void APP_DISPLAY_DeleteAllTrackListItems(void)
{
    deleteAllListBoxItems();
    clrCurrentTrackText();    
}

static void APP_DISPLAY_InitTrackList(const char* const pErrorMsg)
{
    initListBox(pErrorMsg);
}

static void APP_DISPLAY_updateTrackListReq(void)
{
    uint32_t index = 0;
    uint32_t numTracks = 0;
    APP_SDCARD_AUDIO_CARD_FILE_PATH* TablePointer;
    
    TablePointer = APP_SDCARD_AUDIO_GetFileTablePointer();
    numTracks = APP_SDCARD_AUDIO_FileCountGet();
    
    //clear the entire tracks list
    APP_DISPLAY_DeleteAllTrackListItems();
    
    if (0 == numTracks)
    {
        APP_DISPLAY_InitTrackList((const char*)"No Audio Files To Play!");
    }
    else
    {    
        for (index = 0; index < numTracks; index++)
        {
            APP_DISPLAY_AddTrackListItem((const char*)_APP_DISPLAY_GetFileName(TablePointer[index].path));
        }
        //show the first track as selected
        if (numTracks)
        {
            APP_DISPLAY_SetSelectedTrackReq(0);
            setCurrentTrackText();
        }
    }
}

bool APP_DISPLAY_AudioPlayerEventsHandler(DISP_CMD cmd)
{
    return pushQueue(&displayTaskData.msgQueue, cmd);
}

void APP_DISPLAY_Initialize(void)
{        
    initQueue(&displayTaskData.msgQueue, (uint8_t*)displayTaskData.msgBuffer, MSG_BUFFER_LEN);
    //Register event handler with the SDCARD AUDIO Task
    APP_SDCARD_AUDIO_RegisterEventHandler(APP_DISPLAY_AudioPlayerEventsHandler);
    //Register event handler with Audio Player GUI
    registerGuiEventsHandler(APP_DISPLAY_AudioPlayerEventsHandler);
}

void APP_DISPLAY_Tasks(void)
{
    DISP_CMD cmd = DISP_CMD_MAX;
    
    if (true == APP_DISPLAY_IsGUIScreenInitialized())
    {
        if (true == pullQueue(&displayTaskData.msgQueue, (uint8_t*)&cmd))
        {
            switch(cmd)
            {                
                case DISP_CMD_POPULATE_TRACKLIST_REQ:
                    APP_DISPLAY_updateTrackListReq();
                    break;
                case DISP_CMD_CLEAR_TRACKLIST_REQ:
                    APP_DISPLAY_DeleteAllTrackListItems();
                    APP_DISPLAY_InitTrackList((const char*)"No Audio Files To Play!");                
                    break;
                case DISP_CMD_TRACK_CHANGED_EVT:                
                    APP_SDCARD_AUDIO_RandomTrackSet(APP_DISPLAY_GetSelectedTrack());
                    break;
                case DISP_CMD_TRACK_CHANGE_REQ:
                    APP_DISPLAY_SetSelectedTrackReq(APP_SDCARD_AUDIO_CurrentTrackIdGet());
                    break;
                case DISP_CMD_VOLUME_CHANGED_EVT:
                    APP_SDCARD_AUDIO_VolumeSet(APP_DISPLAY_GetVolumeLevel());                    
                    break;
                case DISP_CMD_VOLUME_CHANGE_REQ:
                    {
                        uint8_t volLevel = 0;
                        bool isSuccess = APP_SDCARD_AUDIO_VolumeGet(&volLevel);
                        if (isSuccess)
                        {
                            APP_DISPLAY_SetVolumeLevelReq(volLevel);
                        }
                    }
                    break;
                case DISP_CMD_MUTE_OFF_EVT:
                    APP_DISPLAY_TurnMuteOffEvent();
                    break;
                case DISP_CMD_MUTE_ON_EVT:
                    APP_DISPLAY_TurnMuteOnEvent();
                    break;
                case DISP_CMD_MUTE_OFF_REQ:
                    APP_DISPLAY_ControlMuteButtonRequest(false);
                    break;
                case DISP_CMD_SHUFFLE_ON_EVT:
                    APP_SDCARD_AUDIO_ShuffleTracksEvent(true);
                    break;
                case DISP_CMD_SHUFFLE_OFF_EVT:
                    APP_SDCARD_AUDIO_ShuffleTracksEvent(false);
                    break;
                case DISP_CMD_LOOP_TRACKLIST_EVT:
                    APP_SDCARD_AUDIO_LoopTrackListEvent(true);
                    break;
                case DISP_CMD_UNLOOP_TRACKLIST_EVT:
                    APP_SDCARD_AUDIO_LoopTrackListEvent(false);
                    break;
                case DISP_CMD_LOOP_SINGLE_TRACK_EVT:
                    APP_SDCARD_AUDIO_LoopSingleTrackEvent(true);
                    break;      
                case DISP_CMD_UPDATE_PROGBAR_IN_PER_REQ:
                    APP_DISPLAY_UpdatePlayerProgressBarReq(APP_SDCARD_AUDIO_GetTrackPlayTimeInPer());
                    APP_DISPLAY_UpdateElapsedTimeReq(APP_SDCARD_AUDIO_GetTrackPlayTime(), APP_SDCARD_AUDIO_GetTotalTrackTimeInBytes(), APP_SDCARD_AUDIO_GetElapsedTrackTimeInBytes());
                    break;
                case DISP_CMD_UPDATE_TOTAL_TRACK_TIME_REQ:
                    APP_DISPLAY_UpdateTrackDurationReq();
                    break;
                case DISP_CMD_UPDATE_ELAPSED_TRACK_TIME_REQ:                    
                    break;
                case DISP_CMD_PLAYER_PAUSE_EVT:
                    APP_DISPLAY_PlayerStateChangeEvent(PLAY_BUTTON_STATES_PAUSE);
                    break;
                case DISP_CMD_PLAYER_PLAY_EVT:
                    APP_DISPLAY_PlayerStateChangeEvent(PLAY_BUTTON_STATES_PLAY);
                    break;
                case DISP_CMD_PLAYER_PAUSE_REQ:
                    APP_DISPLAY_PlayerStateChangeRequest(PLAY_BUTTON_STATES_PAUSE);
                    break;
                case DISP_CMD_USB_MEDIA_FS_MOUNT_ERROR:
                    break;
                case DISP_CMD_SDCARD_MEDIA_FS_MOUNT_ERROR:
                    break;
                case DISP_CMD_USB_MODE_ON_REQ:
                    APP_DISPLAY_ModeChangeRequest(SWITCH_BUTTON_STATES_SWITCH_ON);
                    break;
                case DISP_CMD_SDCARD_MODE_ON_REQ:
                    APP_DISPLAY_ModeChangeRequest(SWITCH_BUTTON_STATES_SWITCH_OFF);
                    break;
                case DISP_CMD_TRACK_SEEK_EVT:
                    APP_DISPLAY_SeekTrackPositionEvent();
                    break;
                case DISP_CMD_USB_MODE_CHANGE_EVT:
                    if (APP_STREAMING_SOURCE_USB == APP_DISPLAY_ReadModeSwitch())
                    {
                        //USB mode selected
                        APP_SDCARD_AUDIO_SuspendStreaming();  
                        APP_StreamSourceSet(APP_STREAMING_SOURCE_USB);                    
                        APP_SDCARD_AUDIO_Initialize();
                    }
                    else
                    {
                        //SD card mode selected
                        APP_SDCARD_AUDIO_SuspendStreaming();  
                        APP_StreamSourceSet(APP_STREAMING_SOURCE_SDCARD);                    
                        APP_SDCARD_AUDIO_Initialize();                    
                    }                                    
                    break;
                case DISP_CMD_MAX:
                    break;
                default:
                    break;
            }
        }
    }    
}




