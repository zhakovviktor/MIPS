/*********************************************************************
*                                                                    *
*                SEGGER Microcontroller GmbH & Co. KG                *
*        Solutions for real time microcontroller applications        *
*                                                                    *
**********************************************************************
*                                                                    *
* C-file generated by:                                               *
*                                                                    *
*        GUI_Builder for emWin version 5.34                          *
*        Compiled May 18 2018, 19:53:39                              *
*        (c) 2016 Segger Microcontroller GmbH & Co. KG               *
*                                                                    *
**********************************************************************
*                                                                    *
*        Internet: www.segger.com  Support: support@segger.com       *
*                                                                    *
**********************************************************************
*/

// USER START (Optionally insert additional includes)
// USER END

#include "DIALOG.h"
#include <stdint.h>
#include <stdio.h>
#include "audio_player_dialog.h"


/*********************************************************************
*
*       Defines
*
**********************************************************************
*/
#define ID_MAIN_WINDOW          (GUI_ID_USER + 0x00)
#define ID_BG_IMAGE             (GUI_ID_USER + 0x01)
#define ID_REPEAT_BUTTON        (GUI_ID_USER + 0x02)
#define ID_SHUFFLE_BUTTON       (GUI_ID_USER + 0x03)
#define ID_PREV_BUTTON          (GUI_ID_USER + 0x04)
#define ID_PLAY_BUTTON          (GUI_ID_USER + 0x05)
#define ID_NEXT_BUTTON          (GUI_ID_USER + 0x06)
#define ID_MUTE_BUTTON          (GUI_ID_USER + 0x07)
#define ID_SLIDER               (GUI_ID_USER + 0x08)
#define ID_SETTINGS_BUTTON      (GUI_ID_USER + 0x09)
#define ID_PROGRESS_BAR         (GUI_ID_USER + 0x0A)
#define ID_ELAPSED_TRACK_TIME   (GUI_ID_USER + 0x0B)
#define ID_TOTAL_TRACK_TIME     (GUI_ID_USER + 0x0C)
#define ID_TRACK_NAME_TEXT      (GUI_ID_USER + 0x0D)
#define ID_LISTBOX              (GUI_ID_USER + 0x0E)
#define ID_SETTINGS_WINDOW      (GUI_ID_USER + 0x0F)
#define ID_SWITCH_BUTTON_0      (GUI_ID_USER + 0x10)
#define ID_SWITCH_BUTTON_1      (GUI_ID_USER + 0x11)
#define ID_SWITCH_BUTTON_2      (GUI_ID_USER + 0x12)
#define ID_SET_DLG_ITEM_1_TEXT  (GUI_ID_USER + 0x13)
#define ID_SET_DLG_ITEM_2_TEXT  (GUI_ID_USER + 0x14)
#define ID_SET_DLG_ITEM_3_TEXT  (GUI_ID_USER + 0x15)
#define ID_SLIDER_TRACK_SEEKER  (GUI_ID_USER + 0x16)
#define ID_DEMO_NAME            (GUI_ID_USER + 0x17)

#define GUI_LIGHT_BLUE          (0x00D2E64B)
#define GUI_GRAY_30             (0x00303030)
#define GUI_GRAY_20             (0x00202020)

#define TOGGLE_STATE(val)       (val ^= 0x01)
#define DEMO_NAME_STRING        "Audio Player / Zhakov V. Graduate Work"

static WM_HWIN hWinMainDialog;
static WM_HWIN hWinSettingsDialog;
static bool isGUIScreenInitialized = false;
static AUDIO_PLAYER_GUI_EVENTS_NOTIFY audioPlayerGuiEventsNotify = NULL;

// USER START (Optionally insert additional defines)
// USER END

/*********************************************************************
*
*       Static data
*
**********************************************************************
*/

extern GUI_CONST_STORAGE GUI_BITMAP bmplayButton_75_75;
extern GUI_CONST_STORAGE GUI_BITMAP bmpauseButton_75_75;
extern GUI_CONST_STORAGE GUI_BITMAP bmun_muteButton_30_30;
extern GUI_CONST_STORAGE GUI_BITMAP bmmuteButton_30_30;
extern GUI_CONST_STORAGE GUI_BITMAP bmnext_track_50_50;
extern GUI_CONST_STORAGE GUI_BITMAP bmprev_track_50_50;
extern GUI_CONST_STORAGE GUI_BITMAP bmrepeat_off_40_40;
extern GUI_CONST_STORAGE GUI_BITMAP bmrepeat_on_40_40;
extern GUI_CONST_STORAGE GUI_BITMAP bmrepeat_single_40_40;
extern GUI_CONST_STORAGE GUI_BITMAP bmshuffle_off_40_40;
extern GUI_CONST_STORAGE GUI_BITMAP bmshuffle_on_40_40;
extern GUI_CONST_STORAGE GUI_BITMAP bmsettings_off_50_50;
extern GUI_CONST_STORAGE GUI_BITMAP bmsettings_on_50_50;
extern GUI_CONST_STORAGE GUI_BITMAP bmimage_background1_480_272;
extern GUI_CONST_STORAGE GUI_BITMAP bmimage_background2_480_272;


// USER START (Optionally insert additional static data)
// USER END

/*********************************************************************
*
*       mainDialogCreate
*/

static const GUI_WIDGET_CREATE_INFO mainDialogCreate[] = 
{
    // USER START (Optionally insert additional widgets)
    { WINDOW_CreateIndirect,    "", ID_MAIN_WINDOW, -1, 2, 480, 272, 0, 0x0, 0 },
    { IMAGE_CreateIndirect,     "", ID_BG_IMAGE, 0, 0, 480, 270, 0, 0, 0 },  
    { TEXT_CreateIndirect,      "", ID_DEMO_NAME, 1, 0, 300, 15, 0, 0x0, 0 },                  
    { BUTTON_CreateIndirect,    "", ID_REPEAT_BUTTON, 5, 210, 40, 40, 0, 0x0, sizeof(void*) },    
    { BUTTON_CreateIndirect,    "", ID_SHUFFLE_BUTTON, 50, 210, 40, 40, 0, 0x0, sizeof(void*) },    
    { BUTTON_CreateIndirect,    "", ID_PREV_BUTTON, 95, 205, 50, 50, 0, 0x0, sizeof(void*) },  
    { BUTTON_CreateIndirect,    "", ID_PLAY_BUTTON, 150, 190, 75, 75, 0, 0x0, sizeof(void*) },  
    { BUTTON_CreateIndirect,    "", ID_NEXT_BUTTON, 230, 205, 50, 50, 0, 0x0, sizeof(void*) },   
    { BUTTON_CreateIndirect,    "", ID_MUTE_BUTTON, 285, 214, 30, 30, 0, 0x0, sizeof(void*) },          
    { SLIDER_CreateIndirect,    "", ID_SLIDER, 317, 212, 100, 35, 0, 0x0, sizeof(void*) },    
    { BUTTON_CreateIndirect,    "", ID_SETTINGS_BUTTON, 425, 203, 50, 50, 0, 0x0, sizeof(void*) },            
    { PROGBAR_CreateIndirect,   "", ID_PROGRESS_BAR, 38, 176, 400, 7, 0, 0x0, sizeof(void*) },
    { SLIDER_CreateIndirect,    "", ID_SLIDER_TRACK_SEEKER, 38, 171, 400, 19, 0, 0x0, sizeof(void*) },    
    { TEXT_CreateIndirect,      "", ID_ELAPSED_TRACK_TIME, 8, 174, 28, 10, 0, 0x0, 0 },  
    { TEXT_CreateIndirect,      "", ID_TOTAL_TRACK_TIME, 442, 174, 28, 10, 0, 0x0, 0 },  
    { TEXT_CreateIndirect,      "", ID_TRACK_NAME_TEXT, 14, 187, 130, 20, 0, 0x0, 0 },                  
    { LISTBOX_CreateIndirect,   "", ID_LISTBOX, 10, 15, 200, 155, 0, 0x0, sizeof(void*) },     
    // USER END
};

static const GUI_WIDGET_CREATE_INFO settingsDialogCreate[] = 
{
    { WINDOW_CreateIndirect,    "",     ID_SETTINGS_WINDOW, 320, 10, 155, 148, 0, 0x0, 0 },  
    { BUTTON_CreateIndirect,    "",     ID_SWITCH_BUTTON_0, 80, 3, 70, 32, 0, 0x0, sizeof(void*) },
    { BUTTON_CreateIndirect,    "",     ID_SWITCH_BUTTON_1, 80, 40, 70, 32, 0, 0x0, sizeof(void*) },
    { BUTTON_CreateIndirect,    "",     ID_SWITCH_BUTTON_2, 80, 77, 70, 32, 0, 0x0, sizeof(void*) },
    { TEXT_CreateIndirect, "Mode",      ID_SET_DLG_ITEM_1_TEXT, 7, 14, 70, 15, 0, 0x0, 0 },  
    { TEXT_CreateIndirect, "Play List", ID_SET_DLG_ITEM_2_TEXT, 7, 51, 70, 15, 0, 0x0, 0 },  
    { TEXT_CreateIndirect, "Background", ID_SET_DLG_ITEM_3_TEXT, 7, 88, 70, 15, 0, 0x0, 0 },  
};
/*********************************************************************
*
*       Static code
*
***********************************************************************/


typedef struct
{   
    uint8_t state;
    const GUI_BITMAP* playImage;
    const GUI_BITMAP* pauseImage;
}PLAY_BUTTON_DATA;

typedef struct
{    
    const GUI_BITMAP* buttonStateImage[2];    
}TRACK_CHANGE_BUTTON_DATA;

typedef struct
{
    GUI_COLOR rectColor;
    GUI_COLOR circleColor;
    GUI_COLOR textColor;
}SWITCH_COLOR_SCHEME;

typedef struct
{
    uint8_t switchState;    
    SWITCH_COLOR_SCHEME colorScheme[2];
    uint32_t buttonRadius;    
    char offStateText[30];
    char onStateText[30];
}SWITCH_BUTTON_DATA;

typedef struct
{
    uint8_t numItems;
    uint8_t itemMargin;
    GUI_COLOR dialogBackgroundColor;
    GUI_COLOR dialogItemColor;
}SETTINGS_DIALOG_DATA;

typedef struct
{
    uint8_t state;
    const GUI_BITMAP* buttonStateImage[2];    
}SETTINGS_BUTTON_DATA;

typedef struct
{
    GUI_COLOR itemBackground;
    GUI_COLOR itemText;
}LISTBOX_COLOR_SCHEME;

typedef struct
{
    uint32_t trackIndex;
    bool isDisplayInitMsg;
    LISTBOX_COLOR_SCHEME colorScheme[2];
}LISTBOX_DATA;

typedef struct
{
    uint32_t shaftSize;    
    GUI_COLOR   backgroundColor;
    GUI_COLOR   shaftColor;
}SCROLLBAR_DATA;

typedef struct
{
    GUI_COLOR   activeColor;
    GUI_COLOR   inactiveColor;
    GUI_COLOR   knobColor;    
    uint32_t    knobRadius;
}VOL_SLIDER_COLOR_SCHEME;

typedef struct
{
    uint8_t maxRange;
    uint8_t initialValue;
    uint8_t currValue;
    uint8_t prevValue;
    VOL_SLIDER_COLOR_SCHEME colorScheme;
}VOL_SLIDER_DATA;

typedef struct
{
    uint8_t muteStatus;
    const GUI_BITMAP* buttonStateImage[2];    
}MUTE_BUTTON_DATA;

typedef struct
{
    uint8_t repeatState;
    const GUI_BITMAP* buttonStateImage[3];    
}REPEAT_BUTTON_DATA;

typedef struct
{
    uint8_t shuffleState;
    const GUI_BITMAP* buttonStateImage[2];
}SHUFFLE_BUTTON_DATA;

typedef struct
{
    uint32_t listIndex;
}NEXT_BUTTON_DATA;

typedef struct
{
    GUI_COLOR   activeColor;
    GUI_COLOR   inactiveColor;    
}PROGRESS_BAR_COLOR_SCHEME;

typedef struct
{
    PROGRESS_BAR_COLOR_SCHEME colorScheme;
}PROGRESS_BAR_DATA;

static PLAY_BUTTON_DATA  playButtonData[1] = 
{ 
    {
        .state      = PLAY_BUTTON_STATES_PAUSE, 
        .playImage  = &bmplayButton_75_75, 
        .pauseImage = &bmpauseButton_75_75 
    },
};

static TRACK_CHANGE_BUTTON_DATA trackChangeButtonData[2] = 
{    
    [0] =   {
                .buttonStateImage[0] = &bmnext_track_50_50,
                .buttonStateImage[1] = &bmnext_track_50_50,
            },
    
    [1] =   {
                .buttonStateImage[0] = &bmprev_track_50_50,
                .buttonStateImage[1] = &bmprev_track_50_50,
            },      
};

static SWITCH_BUTTON_DATA switchButtonData[3]=
{
    {
        .switchState = SWITCH_BUTTON_STATES_SWITCH_OFF, 
        {
            [SWITCH_BUTTON_STATES_SWITCH_OFF] =   {
                        .rectColor = GUI_LIGHT_BLUE, 
                        .circleColor = GUI_WHITE, 
                        .textColor = GUI_WHITE
                    }, 
            [SWITCH_BUTTON_STATES_SWITCH_ON] =   {
                        .rectColor = GUI_LIGHT_BLUE, 
                        .circleColor = GUI_WHITE,
                        .textColor = GUI_WHITE
                    },
        },
        .buttonRadius = 12,
        .offStateText = "SD", 
        .onStateText = "Flash"
    },
    {
        .switchState = SWITCH_BUTTON_STATES_SWITCH_OFF, 
        {
            [SWITCH_BUTTON_STATES_SWITCH_OFF] =   {
                        .rectColor = GUI_GRAY_30, 
                        .circleColor = GUI_GRAY_AA, 
                        .textColor = GUI_LIGHTGRAY
                    }, 
            [SWITCH_BUTTON_STATES_SWITCH_ON] =   {
                        .rectColor = GUI_LIGHT_BLUE, 
                        .circleColor = GUI_WHITE,
                        .textColor = GUI_WHITE
                    },
        },
        .buttonRadius = 12,
        .offStateText = "HIDE", 
        .onStateText = "SHOW"
    }, 
    {
        .switchState = SWITCH_BUTTON_STATES_SWITCH_OFF, 
        {
            [SWITCH_BUTTON_STATES_SWITCH_OFF] =   {
                        .rectColor = GUI_LIGHT_BLUE, 
                        .circleColor = GUI_WHITE, 
                        .textColor = GUI_WHITE
                    }, 
            [SWITCH_BUTTON_STATES_SWITCH_ON] =   {
                        .rectColor = GUI_LIGHT_BLUE, 
                        .circleColor = GUI_WHITE,
                        .textColor = GUI_WHITE
                    },
        },
        .buttonRadius = 12,
        .offStateText = "BG 1", 
        .onStateText = "BG 2"
    }, 
};

static VOL_SLIDER_DATA volSliderData[1]=
{
    {
        .maxRange = 100, 
        .initialValue = 50, 
        .currValue = 0, 
        .prevValue =0, 
        {
            .activeColor = GUI_LIGHT_BLUE, 
            .inactiveColor = GUI_GRAY_AA, 
            .knobColor = GUI_LIGHT_BLUE,
            .knobRadius = 8,
        }
    },
};

static MUTE_BUTTON_DATA muteButtonData[1] = 
{
    {
        .muteStatus          = MUTE_BUTTON_STATES_MUTE_OFF,         
        .buttonStateImage[MUTE_BUTTON_STATES_MUTE_OFF] = &bmun_muteButton_30_30, 
        .buttonStateImage[MUTE_BUTTON_STATES_MUTE_ON] = &bmmuteButton_30_30
    },
};

static SETTINGS_BUTTON_DATA settingsButtonData[1] = 
{
    {
        .state = SETTINGS_BUTTON_STATES_HIDE, 
        .buttonStateImage[SETTINGS_BUTTON_STATES_HIDE] = &bmsettings_off_50_50, 
        .buttonStateImage[SETTINGS_BUTTON_STATES_SHOW] = &bmsettings_on_50_50
    },
};

static REPEAT_BUTTON_DATA repeatButtonData[1] =
{
    {
        .repeatState = REPEAT_BUTTON_STATES_REPEAT_OFF, 
        .buttonStateImage[REPEAT_BUTTON_STATES_REPEAT_OFF] = &bmrepeat_off_40_40, 
        .buttonStateImage[REPEAT_BUTTON_STATES_REPEAT_ON] = &bmrepeat_on_40_40, 
        .buttonStateImage[REPEAT_BUTTON_STATES_REPEAT_SINGLE_TRACK] = &bmrepeat_single_40_40
    },
};

static SHUFFLE_BUTTON_DATA shuffleButtonData[1] = 
{
    {
        .shuffleState = SHUFFLE_BUTTON_STATES_SHUFFLE_OFF, 
        .buttonStateImage[SHUFFLE_BUTTON_STATES_SHUFFLE_OFF] = &bmshuffle_off_40_40, 
        .buttonStateImage[SHUFFLE_BUTTON_STATES_SHUFFLE_ON] = &bmshuffle_on_40_40
    },
};

static LISTBOX_DATA listBoxData[1] = 
{
    {
        .trackIndex = 0, 
        .isDisplayInitMsg = false, 
        {
            [0] =   {
                        .itemBackground = GUI_DARKGRAY, 
                        .itemText = GUI_LIGHT_BLUE
                    }, 
            [1] =   {
                        .itemBackground = GUI_LIGHT_BLUE, 
                        .itemText = GUI_WHITE
                    }
        }
    },
};

PROGRESS_BAR_DATA progressBarData[1] = 
{
    {
        {
            GUI_LIGHT_BLUE,
            GUI_GRAY_50,
        },
    },    
};

SCROLLBAR_DATA scrollBarData = 
{       
    .shaftSize = 35,
    .backgroundColor = GUI_GRAY,
    .shaftColor = GUI_LIGHT_BLUE,
};

SETTINGS_DIALOG_DATA settingsDialogData = 
{
    .numItems = 4,
    .itemMargin = 2,
    .dialogBackgroundColor = GUI_TRANSPARENT,
    .dialogItemColor = GUI_DARKGRAY,
};

static void cbProgressBar(WM_MESSAGE* pMsg)
{
    GUI_RECT rectCord;    
    PROGRESS_BAR_DATA* pData;
    uint32_t x_size;
    uint32_t value;
        
    PROGBAR_GetUserData( pMsg->hWin, &pData, sizeof(void *) );
    
    switch( pMsg->MsgId )
    {
        case WM_PAINT:
        {
            if (pData)
            {
                WM_GetClientRect(&rectCord);
                x_size = WM_GetWindowSizeX(pMsg->hWin);            

                value = PROGBAR_GetValue(pMsg->hWin);
                rectCord.x1 = ((value * x_size)/100);
                //Draw active side of progress bar
                GUI_SetColor(pData->colorScheme.activeColor);
                GUI_FillRectEx(&rectCord);    
                //Draw inactive side of progress bar
                GUI_SetColor(pData->colorScheme.inactiveColor);
                rectCord.x0 = rectCord.x1;   
                rectCord.x1 = x_size;
                GUI_FillRectEx(&rectCord); 
            }
            
            break;
        }
        default:
        {
            PROGBAR_Callback(pMsg);
        }
    }   
}

static void cbPlayButton(WM_MESSAGE* pMsg)
{
    PLAY_BUTTON_DATA* pData;
        
    BUTTON_GetUserData( pMsg->hWin, &pData, sizeof(void *) );
    
    switch( pMsg->MsgId )
    {
        case WM_PAINT:
        {
            if( pData )
            {                
                if(PLAY_BUTTON_STATES_PLAY == pData->state)
                {                   
                    //currently in play state, so show pause image
                    GUI_DrawBitmap(pData->pauseImage, 0, 0);                    
                }
                else
                {                      
                    //currently in pause state, so show play image
                    GUI_DrawBitmap(pData->playImage, 0, 0);                   
                }
            }            
            break;
        }
        default:
        {
            BUTTON_Callback(pMsg);
        }
    }   
}

static void cbSettingsButton(WM_MESSAGE* pMsg)
{
    SETTINGS_BUTTON_DATA* pData;
        
    BUTTON_GetUserData( pMsg->hWin, &pData, sizeof(void *) );
    
    switch( pMsg->MsgId )
    {
        case WM_PAINT:        
            if( pData )
            {          
                GUI_DrawBitmap(pData->buttonStateImage[pData->state], 0, 0);                
            }            
            break;        
        default:        
            BUTTON_Callback(pMsg);        
    }   
}

static void cbSwitchButton(WM_MESSAGE* pMsg)
{
    SWITCH_BUTTON_DATA* pData;        
    GUI_RECT rectCord;
    uint32_t y_size;
                
    BUTTON_GetUserData( pMsg->hWin, &pData, sizeof(void *) );
    
    switch( pMsg->MsgId )
    {
        case WM_PAINT:
        {                             
            WM_GetClientRect(&rectCord);            
            y_size = WM_GetWindowSizeY(pMsg->hWin);
                                                                                    
            if (pData)
            {                                
                //Draw outer rectangle
                GUI_DrawGradientRoundedH(rectCord.x0, rectCord.y0+2, rectCord.x1, rectCord.y1, 10, GUI_GRAY_20, GUI_GRAY_20);                            
                //Draw inner rectangle + Draw circle + Draw text
                GUI_DrawGradientRoundedH(rectCord.x0+5, rectCord.y0+7, rectCord.x1-5, rectCord.y1-5, 10, pData->colorScheme[pData->switchState].rectColor, pData->colorScheme[pData->switchState].rectColor);
                GUI_SetColor(pData->colorScheme[pData->switchState].circleColor);
                //coordinates are relative to the rectangle in which the circle is being drawn 
                if (SWITCH_BUTTON_STATES_SWITCH_OFF == pData->switchState)
                {
                    GUI_FillCircle(5+pData->buttonRadius, y_size/2, pData->buttonRadius);   
                }
                else
                {
                    GUI_FillCircle(5 + pData->buttonRadius*2 + 12 + pData->buttonRadius, y_size/2, pData->buttonRadius); 
                }
                GUI_SetColor(pData->colorScheme[pData->switchState].textColor);
                GUI_SetTextMode(GUI_TM_TRANS);
                if (SWITCH_BUTTON_STATES_SWITCH_OFF == pData->switchState)
                {
                    GUI_DispStringAt(pData->offStateText, 5 + pData->buttonRadius*2 + 7, (y_size/2)-1);
                }
                else
                {
                    GUI_DispStringAt(pData->onStateText, 11, (y_size/2)-1);
                }
                GUI_SetTextMode(GUI_TM_NORMAL);                                
            }
            break;
        }
        default:
        {
            BUTTON_Callback(pMsg);
        }
    }   
}

static void cbVolMuteButton(WM_MESSAGE* pMsg)
{
    MUTE_BUTTON_DATA* pData;    
                        
    BUTTON_GetUserData( pMsg->hWin, &pData, sizeof(void *) );
    
    switch( pMsg->MsgId )
    {
        case WM_PAINT:
        {                             
            if (pData)
            {
                GUI_DrawBitmap(pData->buttonStateImage[pData->muteStatus], 0, 0);                
            }                                                            
            break;
        }
        default:
        {
            BUTTON_Callback(pMsg);
        }
    }   
}

static void cbTrackButton(WM_MESSAGE* pMsg)
{
    TRACK_CHANGE_BUTTON_DATA* pData;            
                    
    BUTTON_GetUserData( pMsg->hWin, &pData, sizeof(void *) );
    
    switch( pMsg->MsgId )
    {
        case WM_PAINT:
        {                             
            if (pData)
            {
                GUI_DrawBitmap(pData->buttonStateImage[BUTTON_IsPressed(pMsg->hWin)], 0, 0);                
            }                                                            
            break;
        }
        default:
        {
            BUTTON_Callback(pMsg);
        }
    }   
}
static void cbRepeatButton(WM_MESSAGE* pMsg)
{
    REPEAT_BUTTON_DATA* pData;            
                    
    BUTTON_GetUserData( pMsg->hWin, &pData, sizeof(void *) );
    
    switch( pMsg->MsgId )
    {
        case WM_PAINT:
        {                             
            if (pData)
            {
                GUI_DrawBitmap(pData->buttonStateImage[pData->repeatState], 0, 0);                
            }                                                            
            break;
        }
        default:
        {
            BUTTON_Callback(pMsg);
        }
    }   
}

static void cbScrollBar(WM_MESSAGE* pMsg)
{                       
    GUI_RECT rectCord;
    uint32_t numItemsInScrollBar = 0;
    uint32_t upperHalf, lowerHalf;
    uint32_t scrollBarVal = 0;       
    uint32_t pageSize = 0;
    
    const SCROLLBAR_DATA* const pData = &scrollBarData;        
    
    switch( pMsg->MsgId )
    {
        case WM_PAINT:
        {                                            
            WM_GetClientRect(&rectCord);            
            scrollBarVal = SCROLLBAR_GetValue(pMsg->hWin);
            numItemsInScrollBar = SCROLLBAR_GetNumItems(pMsg->hWin); 
            pageSize = SCROLLBAR_GetPageSize(pMsg->hWin);
            if (scrollBarVal > 0 && numItemsInScrollBar > pageSize)
            {
                upperHalf = (((rectCord.y1-pData->shaftSize) * scrollBarVal)/(numItemsInScrollBar-pageSize));
                lowerHalf = (rectCord.y1-pData->shaftSize) - upperHalf;
                rectCord.y0 = 0; 
                rectCord.y1 = upperHalf;
                GUI_SetColor(pData->backgroundColor);
                GUI_FillRectEx(&rectCord);
                rectCord.y0 = rectCord.y1+1;
                rectCord.y1 += pData->shaftSize;
                GUI_SetColor(pData->shaftColor);
                GUI_FillRectEx(&rectCord);
                rectCord.y0 = rectCord.y1+1;
                rectCord.y1 += lowerHalf;
                GUI_SetColor(GUI_GRAY);
                GUI_FillRectEx(&rectCord);                                                
            }
            else
            {
                lowerHalf = (rectCord.y1-pData->shaftSize);
                GUI_SetColor(pData->shaftColor);
                rectCord.y0 = 0;
                rectCord.y1 = pData->shaftSize;
                GUI_FillRectEx(&rectCord);
                rectCord.y0 = rectCord.y1+1;
                rectCord.y1 += lowerHalf;
                GUI_SetColor(pData->backgroundColor);
                GUI_FillRectEx(&rectCord);
            }                        
            break;
        }
        default:
        {
            SCROLLBAR_Callback(pMsg);
        }
    }   
}

static void cbShuffleButton(WM_MESSAGE* pMsg)
{
    SHUFFLE_BUTTON_DATA* pData = NULL;            
                    
    BUTTON_GetUserData( pMsg->hWin, &pData, sizeof(void *) );
    
    switch( pMsg->MsgId )
    {
        case WM_PAINT:
        {                             
            if (pData)
            {
                GUI_DrawBitmap(pData->buttonStateImage[pData->shuffleState], 0, 0);                
            }                                                            
            break;
        }
        default:
        {
            BUTTON_Callback(pMsg);
        }
    }   
}

static void cbSlider1(WM_MESSAGE* pMsg)
{                                
    switch( pMsg->MsgId )
    {
        case WM_PAINT:
        {                            
            break;
        }
        default:
        {
            SLIDER_Callback(pMsg);
        }
    }   
}

static void cbSlider(WM_MESSAGE* pMsg)
{        
    uint32_t x_size = 0;    
    GUI_RECT rectCord;       
    uint32_t volSliderLeftSide = 0;
    uint32_t knobRadius = 0;
    VOL_SLIDER_DATA* pData = NULL;
    
    SLIDER_GetUserData( pMsg->hWin, &pData, sizeof(void *) );
                    
    switch( pMsg->MsgId )
    {
        case WM_PAINT:
        {                
            if (pData)
            {
                x_size = WM_GetWindowSizeX(pMsg->hWin);                

                WM_GetWindowRectEx(pMsg->hWin, &rectCord );
                WM_GetClientRect(&rectCord);    

                knobRadius = pData->colorScheme.knobRadius;
                pData->currValue = SLIDER_GetValue(pMsg->hWin);            
                volSliderLeftSide = (pData->currValue * (x_size - (knobRadius*2)))/pData->maxRange;
                GUI_SetColor(pData->colorScheme.activeColor);
                GUI_FillRect(knobRadius, (rectCord.y1/2), knobRadius+volSliderLeftSide, (rectCord.y1/2)+3);                
                GUI_SetColor(pData->colorScheme.inactiveColor);                
                GUI_FillRect(knobRadius + volSliderLeftSide, (rectCord.y1/2), (x_size-knobRadius), (rectCord.y1/2)+3);
                GUI_SetColor(pData->colorScheme.knobColor);
                //coordinates are relative to the rectangle in which the circle is being drawn                            
                GUI_FillCircle(knobRadius + volSliderLeftSide, (rectCord.y1/2), knobRadius); 
            }                        
            break;
        }
        default:
        {
            SLIDER_Callback(pMsg);
        }
    }   
}

static int cbListboxOwnerDraw(const WIDGET_ITEM_DRAW_INFO* pDrawItemInfo)
{
    GUI_RECT rInside;
    uint32_t height = 0;
    uint32_t width  = 0;    
    uint32_t selectedItemIndex, isCurrentItemIndexSelected;
    const GUI_FONT* oldFont;
    LISTBOX_DATA* pData = NULL;
      
    height = GUI_GetFontDistY() + 18;
    WM_GetInsideRectEx(pDrawItemInfo->hWin, &rInside);
    width = rInside.x1;
    
    LISTBOX_GetUserData(pDrawItemInfo->hWin, &pData, sizeof(void *) );        
        
    switch (pDrawItemInfo->Cmd) 
    {
        case WIDGET_ITEM_GET_XSIZE:
            return width;
        case WIDGET_ITEM_GET_YSIZE:
            return height;
        case WIDGET_ITEM_DRAW_FRAME:
            break;
        case WIDGET_ITEM_DRAW: 
        {            
            char itemTextBuffer[50] = {0};
            GUI_RECT rect = 
            {
                pDrawItemInfo->x0,
                pDrawItemInfo->y0,
                width,
                pDrawItemInfo->y0 + height
            };            
            if (true == pData->isDisplayInitMsg)
            {
                sprintf(&itemTextBuffer[0], "%s", "      ");
            }
            else
            {
                sprintf(&itemTextBuffer[0], "%02d.   ", pDrawItemInfo->ItemIndex + 1);
            }
            LISTBOX_GetItemText(pDrawItemInfo->hWin, pDrawItemInfo->ItemIndex, (char*)&itemTextBuffer[6], sizeof(itemTextBuffer));
            selectedItemIndex = LISTBOX_GetSel(pDrawItemInfo->hWin);
            isCurrentItemIndexSelected = pDrawItemInfo->ItemIndex == selectedItemIndex ? 1 : 0;
            if (isCurrentItemIndexSelected && (false == pData->isDisplayInitMsg))
            {
                GUI_SetColor(pData->colorScheme[isCurrentItemIndexSelected].itemBackground);
            }
            else
            {
                GUI_SetColor(pData->colorScheme[0].itemBackground);
            }
            GUI_FillRect(rect.x0, rect.y0+1, rect.x1, rect.y1+1);    
            GUI_SetColor(pData->colorScheme[isCurrentItemIndexSelected].itemText);
            GUI_SetTextMode(GUI_TM_TRANS);
            //give some horizontal spacing to the text in the item box
            rect.x0 += 10;
            oldFont = GUI_SetFont(GUI_FONT_10_ASCII); 
            GUI_DispStringInRectMax((char *)itemTextBuffer, &rect, GUI_TA_VCENTER | GUI_TA_LEFT, 30);
            GUI_SetFont(oldFont);
        }
        break;
        default:
            return LISTBOX_OwnerDraw(pDrawItemInfo);
    }
    return 0;
}

static void drawSettingsDialogItems(WM_HWIN hWin)
{
    int32_t   xSize;
    int32_t   ySize;
    GUI_RECT   rect;
    uint8_t    numItems;
    uint32_t   itemSize;
    
    xSize = WM_GetWindowSizeX(hWin);
    ySize = WM_GetWindowSizeY(hWin);            

    //draw background
    GUI_SetColor(settingsDialogData.dialogBackgroundColor);
    GUI_FillRect(0, 0, xSize - 1, ySize - 1);
    
    //draw items
    GUI_SetColor(settingsDialogData.dialogItemColor);
    itemSize = (ySize - ((uint32_t)settingsDialogData.itemMargin * settingsDialogData.numItems))/(uint32_t)settingsDialogData.numItems;
    
    rect.x0 = 1;
    rect.x1 = xSize-1;
    rect.y0 = settingsDialogData.itemMargin;
    rect.y1 = rect.y0 + itemSize;
    
    for (numItems = 0; numItems < settingsDialogData.numItems; numItems++)
    {
        GUI_FillRectEx(&rect);
        rect.y0 = rect.y1 + settingsDialogData.itemMargin;
        rect.y1 = rect.y0 + itemSize;
    }            
}


static void cbSettingsDialog(WM_MESSAGE* pMsg) 
{
    const void* pVoid;
    WM_HWIN    hItem;        
    uint32_t   NCode;
    uint32_t   Id;    
            
    switch (pMsg->MsgId) 
    {
        case WM_INIT_DIALOG:   
            hItem = pMsg->hWin;
            WINDOW_SetBkColor(hItem, GUI_DARKGRAY);
            
            hItem = WM_GetDialogItem(pMsg->hWin, ID_SWITCH_BUTTON_0); 
            pVoid = (const void*)&switchButtonData[0];
            BUTTON_SetUserData(hItem, (const void*)&pVoid, sizeof(void *));            
            WM_SetCallback( hItem, cbSwitchButton);
        
            hItem = WM_GetDialogItem(pMsg->hWin, ID_SWITCH_BUTTON_1); 
            pVoid = (const void*)&switchButtonData[1];
            BUTTON_SetUserData(hItem, (const void*)&pVoid, sizeof(void *));            
            WM_SetCallback( hItem, cbSwitchButton);
            
            hItem = WM_GetDialogItem(pMsg->hWin, ID_SWITCH_BUTTON_2); 
            pVoid = (const void*)&switchButtonData[2];
            BUTTON_SetUserData(hItem, (const void*)&pVoid, sizeof(void *));            
            WM_SetCallback( hItem, cbSwitchButton);

            hItem = WM_GetDialogItem(pMsg->hWin, ID_SET_DLG_ITEM_1_TEXT);
            TEXT_SetTextColor(hItem, GUI_WHITE);
            TEXT_SetFont(hItem, GUI_FONT_16_ASCII);

            hItem = WM_GetDialogItem(pMsg->hWin, ID_SET_DLG_ITEM_2_TEXT);
            TEXT_SetTextColor(hItem, GUI_WHITE);
            TEXT_SetFont(hItem, GUI_FONT_16_ASCII);
            
            hItem = WM_GetDialogItem(pMsg->hWin, ID_SET_DLG_ITEM_3_TEXT);
            TEXT_SetTextColor(hItem, GUI_WHITE);
            TEXT_SetFont(hItem, GUI_FONT_16_ASCII);

            break;    
        case WM_PAINT:
            
            drawSettingsDialogItems(pMsg->hWin);
            
            break;
        case WM_NOTIFY_PARENT:
            Id    = WM_GetId(pMsg->hWinSrc);
            NCode = pMsg->Data.v;
            switch(Id) 
            {
                case ID_SWITCH_BUTTON_0: // Notifications sent by 'B3'
                    switch(NCode) 
                    {
                        case WM_NOTIFICATION_CLICKED:
                            // USER START (Optionally insert code for reacting on notification message)
                            // USER END
                            break;
                        case WM_NOTIFICATION_RELEASED:
                            // USER START (Optionally insert code for reacting on notification message)
                            TOGGLE_STATE(switchButtonData[0].switchState);
                            audioPlayerGuiEventsNotify(DISP_CMD_USB_MODE_CHANGE_EVT);
                            // USER END                                  
                            break;      
                    }
                    break;
                case ID_SWITCH_BUTTON_1: // Notifications sent by 'B3'
                    switch(NCode) 
                    {
                        case WM_NOTIFICATION_CLICKED:
                            // USER START (Optionally insert code for reacting on notification message)
                            // USER END
                            break;
                        case WM_NOTIFICATION_RELEASED:
                            // USER START (Optionally insert code for reacting on notification message)
                            {
                                SWITCH_BUTTON_DATA* pTrackListSwitchButtonData;                        
                                hItem = WM_GetDialogItem(pMsg->hWin, ID_SWITCH_BUTTON_1);
                                BUTTON_GetUserData( hItem, &pTrackListSwitchButtonData, sizeof(void *) );
                                TOGGLE_STATE(pTrackListSwitchButtonData->switchState);
                                hItem = WM_GetDialogItem(hWinMainDialog, ID_LISTBOX); 
                                if (SWITCH_BUTTON_STATES_SWITCH_OFF == pTrackListSwitchButtonData->switchState)
                                {
                                    WM_HideWindow(hItem);                                    
                                }
                                else
                                {
                                    WM_ShowWindow(hItem);                                    
                                }
                            // USER END                                  
                            }
                        break;      
                    }
                    break;    
                case ID_SWITCH_BUTTON_2: // Notifications sent by 'B3'
                    switch(NCode) 
                    {
                        case WM_NOTIFICATION_CLICKED:
                            // USER START (Optionally insert code for reacting on notification message)
                            // USER END
                            break;
                        case WM_NOTIFICATION_RELEASED:
                        {
                            // USER START (Optionally insert code for reacting on notification message)
                            SWITCH_BUTTON_DATA* pBackgroundImageSelSwitchData;                        
                            hItem = WM_GetDialogItem(pMsg->hWin, ID_SWITCH_BUTTON_2);
                            BUTTON_GetUserData( hItem, &pBackgroundImageSelSwitchData, sizeof(void *) );
                            TOGGLE_STATE(pBackgroundImageSelSwitchData->switchState);
                            if (SWITCH_BUTTON_STATES_SWITCH_OFF == pBackgroundImageSelSwitchData->switchState)
                            {
                                hItem = WM_GetDialogItem(hWinMainDialog, ID_BG_IMAGE);                
                                IMAGE_SetBitmap(hItem, &bmimage_background2_480_272); 
                            }
                            else
                            {
                                hItem = WM_GetDialogItem(hWinMainDialog, ID_BG_IMAGE);                
                                IMAGE_SetBitmap(hItem, &bmimage_background1_480_272);
                            }
                        }
                        // USER END                                  
                        break;      
                    }
                    break;
            }
            break;
        default:           
            WM_DefaultProc(pMsg);
        break;
    }
}


/*********************************************************************
*
*       cbMainDialog
*/
static void cbMainDialog(WM_MESSAGE* pMsg) 
{    
    WM_HWIN         hItem;    
    uint32_t        NCode;
    uint32_t        Id;
    const void*     pVoid;    
    uint32_t        index;
    // USER START (Optionally insert additional variables)
    // USER END

    switch (pMsg->MsgId) 
    {
        case WM_INIT_DIALOG:

            hItem = pMsg->hWin;          
            
            hItem = WM_GetDialogItem(pMsg->hWin, ID_DEMO_NAME);
            TEXT_SetTextColor(hItem, GUI_WHITE);
            TEXT_SetFont(hItem, GUI_FONT_16_ASCII);
            TEXT_SetText(hItem, DEMO_NAME_STRING);

            hItem = WM_GetDialogItem(pMsg->hWin, ID_TRACK_NAME_TEXT);
            TEXT_SetTextColor(hItem, GUI_WHITE);
            TEXT_SetFont(hItem, GUI_FONT_10_ASCII);
    
            hItem = WM_GetDialogItem(pMsg->hWin, ID_ELAPSED_TRACK_TIME);
            TEXT_SetTextColor(hItem, GUI_WHITE);
            TEXT_SetFont(hItem, GUI_FONT_10_ASCII);
            TEXT_SetText(hItem, "00:00");

            hItem = WM_GetDialogItem(pMsg->hWin, ID_TOTAL_TRACK_TIME);
            TEXT_SetTextColor(hItem, GUI_WHITE);
            TEXT_SetFont(hItem, GUI_FONT_10_ASCII);

            hItem = WM_GetDialogItem(pMsg->hWin, ID_PLAY_BUTTON);   
            pVoid = &playButtonData[0];            
            BUTTON_SetUserData( hItem, (const void*)&pVoid, sizeof(void *));
            WM_SetHasTrans(hItem);
            WM_SetCallback( hItem, cbPlayButton);

            hItem = WM_GetDialogItem(pMsg->hWin, ID_SETTINGS_BUTTON);   
            pVoid = &settingsButtonData[0];            
            BUTTON_SetUserData( hItem, (const void*)&pVoid, sizeof(void *));
            WM_SetHasTrans(hItem);
            WM_SetCallback( hItem, cbSettingsButton);          

            hItem = WM_GetDialogItem(pMsg->hWin, ID_MUTE_BUTTON); 
            pVoid = &muteButtonData[0];
            BUTTON_SetUserData(hItem, (const void*)&pVoid, sizeof(void *));                
            WM_SetCallback( hItem, cbVolMuteButton);
    
            hItem = WM_GetDialogItem(pMsg->hWin, ID_NEXT_BUTTON); 
            pVoid = &trackChangeButtonData[0];
            BUTTON_SetUserData(hItem, (const void*)&pVoid, sizeof(void *));                
            WM_SetCallback( hItem, cbTrackButton);

            hItem = WM_GetDialogItem(pMsg->hWin, ID_PREV_BUTTON); 
            pVoid = &trackChangeButtonData[1];
            BUTTON_SetUserData(hItem, (const void*)&pVoid, sizeof(void *));                
            WM_SetCallback( hItem, cbTrackButton);

            hItem = WM_GetDialogItem(pMsg->hWin, ID_REPEAT_BUTTON); 
            pVoid = &repeatButtonData[0];
            BUTTON_SetUserData(hItem, (const void*)&pVoid, sizeof(void *));                
            WM_SetCallback( hItem, cbRepeatButton);

            hItem = WM_GetDialogItem(pMsg->hWin, ID_SHUFFLE_BUTTON); 
            pVoid = &shuffleButtonData[0];
            BUTTON_SetUserData(hItem, (const void*)&pVoid, sizeof(void *));                
            WM_SetCallback( hItem, cbShuffleButton);

            hItem = WM_GetDialogItem(pMsg->hWin, ID_LISTBOX); 
            pVoid = &listBoxData[0];
            LISTBOX_SetUserData(hItem, (const void*)&pVoid, sizeof(void *));               
            LISTBOX_EnableWrapMode(hItem, 1);
            LISTBOX_SetItemSpacing(hItem, 10);            
            SCROLLBAR_CreateAttached(hItem, SCROLLBAR_CF_VERTICAL);
            LISTBOX_SetOwnerDraw(hItem, cbListboxOwnerDraw);            
            WM_SetHasTrans(hItem);    
            WM_HideWindow(hItem);

            hItem = WM_GetDialogItem(pMsg->hWin, GUI_ID_VSCROLL);               
            WM_SetCallback( hItem, cbScrollBar);
            
            hItem = WM_GetDialogItem(pMsg->hWin, ID_SLIDER_TRACK_SEEKER);             
            SLIDER_SetRange(hItem, 0, 100);
            SLIDER_SetValue(hItem, 0);
            SLIDER_SetNumTicks(hItem, 101);
            WM_SetCallback( hItem, cbSlider1);

            hItem = WM_GetDialogItem(pMsg->hWin, ID_PROGRESS_BAR);             
            PROGBAR_SetMinMax(hItem, 0, 100);
            PROGBAR_SetValue(hItem, 0);
            pVoid = &progressBarData[0];
            PROGBAR_SetUserData(hItem, (const void*)&pVoid, sizeof(void *));
            WM_SetCallback( hItem, cbProgressBar);

            hItem = WM_GetDialogItem(pMsg->hWin, ID_SLIDER); 
            pVoid = &volSliderData[0];
            SLIDER_SetUserData(hItem, (const void*)&pVoid, sizeof(void *));
            SLIDER_SetRange(hItem, 0, volSliderData[0].maxRange);
            SLIDER_SetValue(hItem, volSliderData[0].initialValue);
            SLIDER_SetNumTicks(hItem, volSliderData[0].maxRange+1);
            volSliderData[0].currValue = volSliderData[0].initialValue;
            WM_SetCallback( hItem, cbSlider);

            hItem = WM_GetDialogItem(pMsg->hWin, ID_BG_IMAGE);                
            IMAGE_SetBitmap(hItem, &bmimage_background2_480_272);   
            
            isGUIScreenInitialized = true;
    
        // USER START (Optionally insert additional code for further widget initialization)
        // USER END
        break;
    
        case WM_PAINT:    
                
    
        break;
    
    case WM_NOTIFY_PARENT:
        Id    = WM_GetId(pMsg->hWinSrc);
        NCode = pMsg->Data.v;
        switch(Id) 
        {
            case ID_PLAY_BUTTON: // Notifications sent by 'B1'
                switch(NCode) 
                {
                    case WM_NOTIFICATION_CLICKED:
                    // USER START (Optionally insert code for reacting on notification message)                      
                    // USER END
                    break;
                    case WM_NOTIFICATION_RELEASED:
                    // USER START (Optionally insert code for reacting on notification message)
                    {            
                        PLAY_BUTTON_DATA* pPlayButtonData;
                        hItem = WM_GetDialogItem(pMsg->hWin, ID_PLAY_BUTTON);
                        BUTTON_GetUserData( hItem, &pPlayButtonData, sizeof(void *) );
                        TOGGLE_STATE(pPlayButtonData->state);
                        if (pPlayButtonData->state == PLAY_BUTTON_STATES_PLAY)
                        {
                            audioPlayerGuiEventsNotify(DISP_CMD_PLAYER_PLAY_EVT);
                        }
                        else
                        {
                            audioPlayerGuiEventsNotify(DISP_CMD_PLAYER_PAUSE_EVT);
                        }
                        //force a redraw of the play button
                        WM_InvalidateWindow(hItem);
                    }        
                    // USER END
                    break;
                // USER START (Optionally insert additional code for further notification handling)
                // USER END
                }
                break;
            case ID_SETTINGS_BUTTON: // Notifications sent by 'B1'
                switch(NCode) 
                {
                    case WM_NOTIFICATION_CLICKED:
                    // USER START (Optionally insert code for reacting on notification message)                      
                    // USER END
                    break;
                    case WM_NOTIFICATION_RELEASED:
                    // USER START (Optionally insert code for reacting on notification message)
                    {            
                        SETTINGS_BUTTON_DATA* pSettingsButtonData;
                        hItem = WM_GetDialogItem(pMsg->hWin, ID_SETTINGS_BUTTON);
                        BUTTON_GetUserData( hItem, &pSettingsButtonData, sizeof(void *) );
                        TOGGLE_STATE(pSettingsButtonData->state);
                        if (SETTINGS_BUTTON_STATES_HIDE == pSettingsButtonData->state)
                        {
                            WM_HideWindow(hWinSettingsDialog);
                        }
                        else
                        {
                            WM_ShowWindow(hWinSettingsDialog);
                        }
                        //force a redraw of the play button
                        WM_InvalidateWindow(hItem);
                    }        
                    // USER END
                    break;
                // USER START (Optionally insert additional code for further notification handling)
                // USER END
                }
                break;            
            case ID_SLIDER: // Notifications sent by 'Volume'
                switch(NCode) 
                {
                    case WM_NOTIFICATION_CLICKED:
                    // USER START (Optionally insert code for reacting on notification message)
                    // USER END
                    break;
                    case WM_NOTIFICATION_RELEASED:              
                    // USER START (Optionally insert code for reacting on notification message)
                    {
                        MUTE_BUTTON_DATA* pMuteButtonData;   
                        //get handle to the mute button
                        hItem = WM_GetDialogItem(pMsg->hWin, ID_MUTE_BUTTON);
                        BUTTON_GetUserData( hItem, &pMuteButtonData, sizeof(void *) );
                        if (MUTE_BUTTON_STATES_MUTE_ON == pMuteButtonData->muteStatus)
                        {
                            pMuteButtonData->muteStatus = MUTE_BUTTON_STATES_MUTE_OFF;
                            //force a redraw of the mute button
                            WM_InvalidateWindow(hItem);
                            audioPlayerGuiEventsNotify(DISP_CMD_MUTE_OFF_EVT);
                        }
                        audioPlayerGuiEventsNotify(DISP_CMD_VOLUME_CHANGED_EVT);
                    }                    
                    // USER END
                    break;
                    case WM_NOTIFICATION_VALUE_CHANGED:
                        // USER START (Optionally insert code for reacting on notification message)
                        //audioPlayerGuiEventsNotify(DISP_CMD_VOLUME_CHANGED_EVT);
                        // USER END
                    break;
                // USER START (Optionally insert additional code for further notification handling)
                // USER END
                }
                break;
                
            case ID_SLIDER_TRACK_SEEKER: // Notifications sent by 'Volume'
                switch(NCode) 
                {
                    case WM_NOTIFICATION_CLICKED:
                    // USER START (Optionally insert code for reacting on notification message)
                    // USER END
                    break;
                    case WM_NOTIFICATION_RELEASED:              
                    // USER START (Optionally insert code for reacting on notification message)
                                            
                        audioPlayerGuiEventsNotify(DISP_CMD_TRACK_SEEK_EVT);
                                        
                    // USER END
                    break;
                    case WM_NOTIFICATION_VALUE_CHANGED:
                        // USER START (Optionally insert code for reacting on notification message)
                        //audioPlayerGuiEventsNotify(DISP_CMD_VOLUME_CHANGED_EVT);
                        // USER END
                    break;
                // USER START (Optionally insert additional code for further notification handling)
                // USER END
                }
                break;

            case ID_REPEAT_BUTTON:
                switch(NCode) 
                {
                    case WM_NOTIFICATION_CLICKED:
                        // USER START (Optionally insert code for reacting on notification message)
                        // USER END
                    break;
                    case WM_NOTIFICATION_RELEASED: 
                    // USER START (Optionally insert code for reacting on notification message)
                    {
                        REPEAT_BUTTON_DATA* pRepeatButtonData;
                        hItem = WM_GetDialogItem(pMsg->hWin, ID_REPEAT_BUTTON);
                        BUTTON_GetUserData( hItem, &pRepeatButtonData, sizeof(void *) );
                        if (pRepeatButtonData)
                        {
                            pRepeatButtonData->repeatState++;
                            if (pRepeatButtonData->repeatState >= REPEAT_BUTTON_STATES_MAX)
                            {
                                pRepeatButtonData->repeatState = REPEAT_BUTTON_STATES_REPEAT_OFF;
                            }
                            WM_InvalidateWindow(hItem);
                    
                            if (REPEAT_BUTTON_STATES_REPEAT_SINGLE_TRACK == pRepeatButtonData->repeatState)
                            {
                                SHUFFLE_BUTTON_DATA* pShuffleButtonData;
                                hItem = WM_GetDialogItem(pMsg->hWin, ID_SHUFFLE_BUTTON);
                                BUTTON_GetUserData( hItem, &pShuffleButtonData, sizeof(void *) );
                                if (SHUFFLE_BUTTON_STATES_SHUFFLE_ON == pShuffleButtonData->shuffleState)
                                {
                                    //turn of shuffling if a single track is on repeat mode
                                    pShuffleButtonData->shuffleState = SHUFFLE_BUTTON_STATES_SHUFFLE_OFF;
                                    WM_InvalidateWindow(hItem);
                                    audioPlayerGuiEventsNotify(DISP_CMD_SHUFFLE_OFF_EVT);
                                }
                            }
                            if (pRepeatButtonData->repeatState == REPEAT_BUTTON_STATES_REPEAT_OFF)
                            {
                                audioPlayerGuiEventsNotify(DISP_CMD_UNLOOP_TRACKLIST_EVT);
                            }
                            else if (pRepeatButtonData->repeatState == REPEAT_BUTTON_STATES_REPEAT_ON)
                            {
                                audioPlayerGuiEventsNotify(DISP_CMD_LOOP_TRACKLIST_EVT);
                            }
                            else
                            {
                                audioPlayerGuiEventsNotify(DISP_CMD_LOOP_SINGLE_TRACK_EVT);
                            }                                        
                        }
                    }
                    // USER END
                    break;                  
                }
                break;
            case ID_SHUFFLE_BUTTON:
                switch(NCode) 
                {
                    case WM_NOTIFICATION_CLICKED:
                    // USER START (Optionally insert code for reacting on notification message)
                    // USER END
                    break;
                    case WM_NOTIFICATION_RELEASED:                    
                    // USER START (Optionally insert code for reacting on notification message)
                    {
                        SHUFFLE_BUTTON_DATA* pShuffleButtonData;
                        REPEAT_BUTTON_DATA* pRepeatButtonData;
                        hItem = WM_GetDialogItem(pMsg->hWin, ID_REPEAT_BUTTON);
                        BUTTON_GetUserData( hItem, &pRepeatButtonData, sizeof(void *) );
                
                        hItem = WM_GetDialogItem(pMsg->hWin, ID_SHUFFLE_BUTTON);
                        BUTTON_GetUserData( hItem, &pShuffleButtonData, sizeof(void *) );
                
                        if (pShuffleButtonData)
                        {
                            //if single track is on repeat mode then don't turn on shuffling
                            if (!((pShuffleButtonData->shuffleState ^ 0x01) && (pRepeatButtonData->repeatState == 2)))
                            {
                                TOGGLE_STATE(pShuffleButtonData->shuffleState);
                                WM_InvalidateWindow(hItem);
                                if (SHUFFLE_BUTTON_STATES_SHUFFLE_ON == pShuffleButtonData->shuffleState)
                                {
                                    audioPlayerGuiEventsNotify(DISP_CMD_SHUFFLE_ON_EVT);
                                }
                                else
                                {
                                    audioPlayerGuiEventsNotify(DISP_CMD_SHUFFLE_OFF_EVT);
                                }
                            }
                        }
                    }
                    // USER END
                    break;      
                }
                break;
        
            case ID_MUTE_BUTTON: // Notifications sent by 'B4'
                switch(NCode) 
                {
                    case WM_NOTIFICATION_CLICKED:      
                        // USER START (Optionally insert code for reacting on notification message)
                        // USER END
                        break;
                    case WM_NOTIFICATION_RELEASED:        
                        // USER START (Optionally insert code for reacting on notification message)
                        {
                            MUTE_BUTTON_DATA* pMuteButtonData;   
                            VOL_SLIDER_DATA* pSliderData;
                            hItem = WM_GetDialogItem(pMsg->hWin, ID_MUTE_BUTTON);
                            BUTTON_GetUserData( hItem, &pMuteButtonData, sizeof(void *) );
                            if (pMuteButtonData)
                            {
                                TOGGLE_STATE(pMuteButtonData->muteStatus);
                            }
                            //update the slider value to 0
                            hItem = WM_GetDialogItem(pMsg->hWin, ID_SLIDER); 
                            SLIDER_GetUserData( hItem, &pSliderData, sizeof(void *) );
                            if (pSliderData)
                            {
                                if (MUTE_BUTTON_STATES_MUTE_ON == pMuteButtonData->muteStatus)
                                {
                                    pSliderData->prevValue = pSliderData->currValue;
                                    pSliderData->currValue = 0;
                                }
                                else
                                {
                                    pSliderData->currValue = pSliderData->prevValue;
                                }
                                //this will cause a redraw of the widget, no need to invalidate the widget
                                SLIDER_SetValue(hItem, pSliderData->currValue);             
                            }  
                            if (MUTE_BUTTON_STATES_MUTE_ON == pMuteButtonData->muteStatus)
                            {
                                audioPlayerGuiEventsNotify(DISP_CMD_MUTE_ON_EVT);
                            }
                            else
                            {
                                audioPlayerGuiEventsNotify(DISP_CMD_MUTE_OFF_EVT);
                            }
                        }
                        // USER END
                        break;      
                }
                break;
            case ID_NEXT_BUTTON:
                switch(NCode) 
                {
                    case WM_NOTIFICATION_CLICKED:      
                        // USER START (Optionally insert code for reacting on notification message)
                        // USER END
                        break;
                    case WM_NOTIFICATION_RELEASED:        
                    // USER START (Optionally insert code for reacting on notification message)
                    {
                        uint32_t maxListItems;
                        LISTBOX_DATA* pListBoxData;   
                        hItem = WM_GetDialogItem(pMsg->hWin, ID_LISTBOX);
                        LISTBOX_GetUserData( hItem, &pListBoxData, sizeof(void *) );                                        
                        maxListItems = LISTBOX_GetNumItems(hItem);
                        if (pListBoxData->trackIndex < (maxListItems-1))
                        {
                            LISTBOX_IncSel(hItem);                         
                        }
                    }
                    // USER END
                    break;      
                }       
                break;
            case ID_PREV_BUTTON:
                switch(NCode) 
                {
                    case WM_NOTIFICATION_CLICKED:      
                        // USER START (Optionally insert code for reacting on notification message)
                        // USER END
                        break;
                    case WM_NOTIFICATION_RELEASED:        
                    // USER START (Optionally insert code for reacting on notification message)
                    {                    
                        LISTBOX_DATA* pListBoxData;   
                        hItem = WM_GetDialogItem(pMsg->hWin, ID_LISTBOX);
                        LISTBOX_GetUserData( hItem, &pListBoxData, sizeof(void *) );
                        if (pListBoxData->trackIndex > 0)
                        {
                            LISTBOX_DecSel(hItem);                         
                        }
                    }
                    // USER END
                    break;      
                }
                break;                    
            case ID_LISTBOX:
                switch(NCode) 
                {            
                    case WM_NOTIFICATION_SEL_CHANGED:
                    {
                        LISTBOX_DATA* pListBoxData;   
                        char itemText[30] = {0};
                        hItem = WM_GetDialogItem(pMsg->hWin, ID_LISTBOX);
                        index = LISTBOX_GetSel(hItem);
                        LISTBOX_GetUserData( hItem, &pListBoxData, sizeof(void *) );
                        pListBoxData->trackIndex = index;
                        LISTBOX_GetItemText(hItem, index, itemText, 25);
                        hItem = WM_GetDialogItem(pMsg->hWin, ID_TRACK_NAME_TEXT);
                        TEXT_SetText(hItem, itemText);
                        audioPlayerGuiEventsNotify(DISP_CMD_TRACK_CHANGED_EVT);                
                    }                               
                    break;            
                }
                break;    
        }
        break;
        // USER START (Optionally insert additional message handling)
        // USER END
    default:
        WM_DefaultProc(pMsg);
        break;
    }
}

/*********************************************************************
*
*       Public code
*
**********************************************************************
*/
/*********************************************************************
*
*       createAudioPlayerScreens
*/

static WM_HWIN createMainScreen(void)
{    
    hWinMainDialog = GUI_CreateDialogBox(mainDialogCreate, GUI_COUNTOF(mainDialogCreate), cbMainDialog, WM_HBKWIN, 0, 0);      
    return hWinMainDialog;
}

static WM_HWIN createSettingsScreen(void)
{    
    hWinSettingsDialog = GUI_CreateDialogBox(settingsDialogCreate, GUI_COUNTOF(settingsDialogCreate), cbSettingsDialog, WM_HBKWIN, 0, 0); 
    WM_HideWindow(hWinSettingsDialog);
    return hWinSettingsDialog;
}

WM_HWIN createAudioPlayerScreens(void)
{
    createMainScreen();
    createSettingsScreen();
    
    return 0;
}

void updateProgressBar(uint8_t progBarVal)
{
    WM_HWIN hItem;
    hItem = WM_GetDialogItem(hWinMainDialog, ID_PROGRESS_BAR);   
    PROGBAR_SetBarColor(hItem, 0,   GUI_LIGHT_BLUE);
    PROGBAR_SetBarColor(hItem, 1,   GUI_RED);
    PROGBAR_SetValue(hItem, progBarVal);
}

void updateTotalTrackTime(const uint8_t* const pStr)
{
    WM_HWIN hItem;
    hItem = WM_GetDialogItem(hWinMainDialog, ID_TOTAL_TRACK_TIME);
    TEXT_SetText(hItem, (const char*) pStr);
}

void updateElapsedTrackTime(const uint8_t* const pStr)
{
    WM_HWIN hItem;
    hItem = WM_GetDialogItem(hWinMainDialog, ID_ELAPSED_TRACK_TIME);
    TEXT_SetText(hItem, (const char*) pStr);
}

void updatePlayButtonState(PLAY_BUTTON_STATES playButtonState)
{
    WM_HWIN hItem;
    PLAY_BUTTON_DATA* pPlayButtonData;
    hItem = WM_GetDialogItem(hWinMainDialog, ID_PLAY_BUTTON);
    BUTTON_GetUserData( hItem, &pPlayButtonData, sizeof(void *) );
    pPlayButtonData->state = playButtonState;
    WM_InvalidateWindow(hItem);    
}

bool getUSBModeSwitchState(void)
{    
    WM_HWIN hItem;
    SWITCH_BUTTON_DATA* pSwitchButtonData;
    hItem = WM_GetDialogItem(hWinSettingsDialog, ID_SWITCH_BUTTON_0);
    BUTTON_GetUserData( hItem, &pSwitchButtonData, sizeof(void *) );
    return pSwitchButtonData->switchState;
}

void setUSBModeSwitchState(SWITCH_BUTTON_STATES switchState)
{
    WM_HWIN hItem;
    SWITCH_BUTTON_DATA* pSwitchButtonData;
    hItem = WM_GetDialogItem(hWinSettingsDialog, ID_SWITCH_BUTTON_0); 
    BUTTON_GetUserData( hItem, &pSwitchButtonData, sizeof(void *) );
    pSwitchButtonData->switchState = switchState;
    WM_InvalidateWindow(hItem);
}

void deleteAllListBoxItems(void)
{
    WM_HWIN hItem;
    uint32_t numItems;
    uint32_t index;
    LISTBOX_DATA* pData;
    
    hItem = WM_GetDialogItem(hWinMainDialog, ID_LISTBOX);   
    numItems = LISTBOX_GetNumItems(hItem);
    for (index = 0; index < numItems; index++)
    {
        LISTBOX_DeleteItem(hItem, 0);
    }
    
    //Also, clear error message mode
    LISTBOX_GetUserData( hItem, &pData, sizeof(void *) );    
    if (pData)
    {
        pData->isDisplayInitMsg = false;
    }
    
    WM_InvalidateWindow(hItem);
}

void addListBoxItem(const char* const pItemString)
{
    WM_HWIN hItem;
    
    hItem = WM_GetDialogItem(hWinMainDialog, ID_LISTBOX);   
    LISTBOX_AddString(hItem, pItemString);
}

uint32_t getListBoxSelectedItem(void)
{
    WM_HWIN hItem;
    
    hItem = WM_GetDialogItem(hWinMainDialog, ID_LISTBOX); 
    return LISTBOX_GetSel(hItem);
}

void setListBoxSelectedItem(uint32_t item)
{
    WM_HWIN hItem;
    
    hItem = WM_GetDialogItem(hWinMainDialog, ID_LISTBOX); 
    return LISTBOX_SetSel(hItem, item);
}

void initListBox(const char* const pInitMsg)
{
    WM_HWIN hItem;
    LISTBOX_DATA* pData;
    
    hItem = WM_GetDialogItem(hWinMainDialog, ID_LISTBOX);
    LISTBOX_GetUserData( hItem, &pData, sizeof(void *) );
    
    if (pData)
    {
        pData->isDisplayInitMsg = true;
    }
    
    addListBoxItem(pInitMsg);
}

uint32_t getTrackSeekValue(void)
{
    WM_HWIN hItem;
    
    hItem = WM_GetDialogItem(hWinMainDialog, ID_SLIDER_TRACK_SEEKER);
    return SLIDER_GetValue(hItem);
}

void setCurrentTrackText(void)
{
    WM_HWIN hItem;    
    uint32_t index = 0;
    char itemText[30] = {0};
    
    hItem = WM_GetDialogItem(hWinMainDialog, ID_LISTBOX);
    index = LISTBOX_GetSel(hItem);    
    LISTBOX_GetItemText(hItem, index, itemText, 25);
    hItem = WM_GetDialogItem(hWinMainDialog, ID_TRACK_NAME_TEXT);
    TEXT_SetText(hItem, itemText);
}

void clrCurrentTrackText(void)
{
    WM_HWIN hItem;
    hItem = WM_GetDialogItem(hWinMainDialog, ID_TRACK_NAME_TEXT);
    TEXT_SetText(hItem, "");
}

uint32_t getSliderValue(void)
{
    WM_HWIN hItem;
    uint32_t value = 0;
    
    hItem = WM_GetDialogItem(hWinMainDialog, ID_SLIDER); 
    value = SLIDER_GetValue(hItem);
    return value;
}

void setSliderValue(uint32_t value)
{
    WM_HWIN hItem;
    
    hItem = WM_GetDialogItem(hWinMainDialog, ID_SLIDER); 
    return SLIDER_SetValue(hItem, value);
}

void volMuteButtonControl(bool isOn)
{
    WM_HWIN hItem;
    MUTE_BUTTON_DATA* pMuteButtonData; 
             
    //get handle to the mute button
    hItem = WM_GetDialogItem(hWinMainDialog, ID_MUTE_BUTTON);
    BUTTON_GetUserData( hItem, &pMuteButtonData, sizeof(void *) );
    
    pMuteButtonData->muteStatus = isOn;
    //force a re-draw by invalidating the widget
    WM_InvalidateWindow(hItem);
}

uint32_t getMaxSliderValue(void)
{
    WM_HWIN hItem;
    int32_t minRange = 0;
    int32_t maxRange = 0;
    
    hItem = WM_GetDialogItem(hWinMainDialog, ID_SLIDER); 
    SLIDER_GetRange(hItem, &minRange, &maxRange);
    
    return maxRange;
}

void registerGuiEventsHandler(AUDIO_PLAYER_GUI_EVENTS_NOTIFY evHandler)
{
    if (evHandler)
    {
        audioPlayerGuiEventsNotify = evHandler;
    }
}

bool isGuiScreenInitialized(void)
{
    return isGUIScreenInitialized;
}

// USER START (Optionally insert additional public code)
// USER END

/*************************** End of file ****************************/
